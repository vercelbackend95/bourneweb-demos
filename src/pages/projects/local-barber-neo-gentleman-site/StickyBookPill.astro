---
const {
  // href zostanie automatycznie podmienione na prawdziwy target z TopNav (Book)
  href = "#book",
  label = "Book",
  hint = "Fast booking",
} = Astro.props;
---

<div class="bm-pillBook" data-bm-pill aria-hidden="true">
  <a class="bm-pillBook__a" href={href} aria-label="Book an appointment">
    <span class="bm-pillBook__dot" aria-hidden="true"></span>
    <span class="bm-pillBook__txt">{label}</span>
    <span class="bm-pillBook__hint">{hint}</span>
    <span class="bm-pillBook__chev" aria-hidden="true">→</span>
  </a>
</div>

<script is:inline>
  (function () {
    const pill = document.querySelector('[data-bm-pill]');
    if (!pill) return;

    const a = pill.querySelector('a');
    const mq = window.matchMedia('(max-width: 820px)');
    const reduce = window.matchMedia?.('(prefers-reduced-motion: reduce)')?.matches;

    // --- discover real section targets from your existing nav links (no guessing ids)
    const links = Array.from(document.querySelectorAll('a[href^="#"]'));

    function pickLink(keyword){
      const k = keyword.toLowerCase();
      return links.find(el => {
        const href = (el.getAttribute('href') || '').toLowerCase();
        const txt  = (el.textContent || '').toLowerCase();
        return href.includes(k) || txt.trim() === k || txt.includes(k);
      });
    }

    const servicesHref = pickLink('services')?.getAttribute('href') || '#services';
    const shopHref     = pickLink('shop')?.getAttribute('href')     || '#shop';
    const bookHref     = pickLink('book')?.getAttribute('href')     || '#book';

    // ensure pill scrolls to the same place as your nav "Book"
    if (a && bookHref) a.setAttribute('href', bookHref);

    const servicesEl = document.querySelector(servicesHref);
    const shopEl = document.querySelector(shopHref);
    const bookEl = document.querySelector(bookHref);
    const footerEl = document.querySelector('footer');

    let shouldShow = false;
    let shouldHide = false;

    function apply(){
      const onMobile = mq.matches;
      const show = onMobile && shouldShow && !shouldHide;
      pill.classList.toggle('is-on', show);
      pill.setAttribute('aria-hidden', show ? 'false' : 'true');
    }

    function markShow(){
      if (!shouldShow){
        shouldShow = true;
        apply();
      }
    }

    // --- observers (preferred)
    const hasIO = 'IntersectionObserver' in window;
    const showOpts = { root: null, threshold: 0.12 };
    const hideOpts = { root: null, threshold: 0.18 };

    function obs(el, cb, opts){
      if (!hasIO || !el) return null;
      const o = new IntersectionObserver((entries) => {
        entries.forEach((e) => cb(e.isIntersecting, e));
      }, opts);
      o.observe(el);
      return o;
    }

    // show once Services OR Shop is reached (or passed)
    obs(servicesEl, (inView, e) => {
      if (inView || (e?.boundingClientRect?.top ?? 1) < 0) markShow();
    }, showOpts);

    obs(shopEl, (inView, e) => {
      if (inView || (e?.boundingClientRect?.top ?? 1) < 0) markShow();
    }, showOpts);

    // hide when booking area is visible or footer is visible
    obs(bookEl, (inView) => { shouldHide = inView; apply(); }, hideOpts);
    obs(footerEl, (inView) => { if (inView) { shouldHide = true; apply(); } }, { root:null, threshold: 0.06 });

    // --- fallback (always works): show after user scrolls past hero-ish area
    // If IO couldn't bind to any targets, use scrollY threshold.
    const needFallback = !servicesEl && !shopEl;
    let ticking = false;

    function onScroll(){
      if (!mq.matches) return;
      if (ticking) return;
      ticking = true;

      requestAnimationFrame(() => {
        ticking = false;
        const y = window.scrollY || document.documentElement.scrollTop || 0;

        // show after ~0.9 viewport height (feels like "after hero")
        if (y > (window.innerHeight * 0.9)) shouldShow = true;

        // hide if booking is likely visible (if we have element)
        if (bookEl){
          const r = bookEl.getBoundingClientRect();
          shouldHide = (r.top < window.innerHeight * 0.55) && (r.bottom > 0);
        }

        apply();
      });
    }

    if (needFallback){
      window.addEventListener('scroll', onScroll, { passive: true });
      window.addEventListener('resize', onScroll, { passive: true });
      onScroll();
    } else {
      // still ensure it can appear if user already scrolled (e.g., refresh mid-page)
      onScroll();
      window.addEventListener('scroll', onScroll, { passive: true });
      window.addEventListener('resize', onScroll, { passive: true });
    }

    // tiny “breath” on first show
    if (!reduce) {
      let last = false;
      const mo = new MutationObserver(() => {
        const now = pill.classList.contains('is-on');
        if (now && !last) {
          pill.classList.add('is-pop');
          setTimeout(() => pill.classList.remove('is-pop'), 420);
        }
        last = now;
      });
      mo.observe(pill, { attributes: true, attributeFilter: ['class'] });
    }

    mq.addEventListener?.('change', apply);
    apply();
  })();
</script>
