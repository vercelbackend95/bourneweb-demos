---
import "./_services.css";

const categories = [
  {
    id: "cuts",
    label: "CUTS",
    image:
      "https://images.unsplash.com/photo-1520975958225-9e049b9f3fd1?auto=format&fit=crop&w=1200&q=80",
    items: [
      ["Men’s haircut", "£22"],
      ["Men’s haircut “Admiral”", "£26"],
      ["Haircut + beard", "£30"],
      ["Skin fade", "£28"],
      ["Children’s haircut", "£17"],
      ["Hair treatments", "£7–£15"],
    ],
  },
  {
    id: "beard",
    label: "BEARD & SHAVE",
    image:
      "https://images.unsplash.com/photo-1517832207067-4db24a2ae47c?auto=format&fit=crop&w=1200&q=80",
    items: [
      ["Beard care (shape)", "£7"],
      ["Beard trim", "£14"],
      ["Beard sculpt + line-up", "£16"],
      ["Beard colouring", "£15"],
      ["Shaving (regular)", "£12"],
      ["Hot towel shave", "£18"],
    ],
  },
  {
    id: "extras",
    label: "EXTRAS",
    image:
      "https://images.unsplash.com/photo-1503951914875-452162b0f3f1?auto=format&fit=crop&w=1200&q=80",
    items: [
      ["Eyebrows", "£6"],
      ["Nose wax", "£8"],
      ["Head massage", "£10"],
      ["Face cleanse", "£9"],
      ["Grey blending", "£12"],
      ["Beard oil treatment", "£7"],
    ],
  },
];
---

<section class="bms" aria-label="Prices and services" id="services">
  <div class="bms__inner">
    <header class="bms__head">
      <p class="bms__eyebrow">PRICES</p>
      <h2 class="bms__title">Pick your service</h2>
      <p class="bms__hint">Use arrows or swipe — image, label and prices move together.</p>
    </header>

    <div class="bms-carousel" data-carousel>
      <button class="bms-nav bms-nav--prev" type="button" aria-label="Previous category" data-prev>
        <span class="bms-nav__icon" aria-hidden="true">←</span>
        <span class="bms-nav__ghost" data-prev-label>EXTRAS</span>
      </button>

      <div class="bms-viewport" data-viewport>
        <div class="bms-track" data-track>
          {categories.map((cat) => (
            <article class="bms-slide" data-slide data-id={cat.id} aria-label={cat.label}>
              <div class="bms-hero">
                <div class="bms-hero__media">
                  <img class="bms-hero__img" src={cat.image} alt="" loading="lazy" />
                  <span class="bms-hero__ring" aria-hidden="true"></span>
                </div>

                <!-- ✅ NAPIS NAD ZDJĘCIEM (czytelny) -->
                <h3 class="bms-hero__label">{cat.label}</h3>
              </div>

              <div class="bms-list" role="list">
                {cat.items.map(([name, price]) => (
                  <div class="bms-row" role="listitem">
                    <div class="bms-row__name">{name}</div>
                    <div class="bms-row__price">{price}</div>
                  </div>
                ))}
              </div>
            </article>
          ))}
        </div>
      </div>

      <button class="bms-nav bms-nav--next" type="button" aria-label="Next category" data-next>
        <span class="bms-nav__ghost" data-next-label>CUTS</span>
        <span class="bms-nav__icon" aria-hidden="true">→</span>
      </button>
    </div>

    <aside class="bms-pill" aria-label="Quick stat">
      <div class="bms-pill__badge">+10%</div>
      <p class="bms-pill__text">
        Most of our first-time clients book again within 30 days. Clean fades. Sharp beards. Zero drama.
      </p>
    </aside>
  </div>

  <script is:inline>
    (() => {
      const root = document.querySelector("[data-carousel]");
      if (!root) return;

      const viewport = root.querySelector("[data-viewport]");
      const track = root.querySelector("[data-track]");
      const prevBtn = root.querySelector("[data-prev]");
      const nextBtn = root.querySelector("[data-next]");
      const prevLabelEl = root.querySelector("[data-prev-label]");
      const nextLabelEl = root.querySelector("[data-next-label]");

      if (!viewport || !track || !prevBtn || !nextBtn || !prevLabelEl || !nextLabelEl) return;

      const baseSlides = Array.from(track.querySelectorAll("[data-slide]"));
      if (baseSlides.length < 2) return;

      const names = baseSlides.map((s) => (s.getAttribute("aria-label") || "").trim());

      // --- build infinite loop: clone last + first
      const firstClone = baseSlides[0].cloneNode(true);
      const lastClone = baseSlides[baseSlides.length - 1].cloneNode(true);
      firstClone.setAttribute("data-clone", "true");
      lastClone.setAttribute("data-clone", "true");

      track.insertBefore(lastClone, baseSlides[0]);
      track.appendChild(firstClone);

      const slides = () => Array.from(track.children);

      let index = 1; // start at first real slide (because 0 is lastClone)
      let width = 0;
      let isDragging = false;
      let startX = 0;
      let currentX = 0;
      let baseTranslate = 0;
      let raf = 0;

      const setTransition = (on) => {
        track.style.transition = on ? "transform 420ms cubic-bezier(.22,1,.36,1)" : "none";
      };

      const setTranslate = (x) => {
        track.style.transform = `translate3d(${x}px,0,0)`;
      };

      const snapToIndex = (i, animate = true) => {
        index = i;
        baseTranslate = -index * width;
        setTransition(animate);
        setTranslate(baseTranslate);
        updateGhostLabels();
      };

      const normalizeIndex = () => {
        const total = slides().length; // base + 2 clones
        const realCount = total - 2;

        // if we moved onto clones, jump (no animation) to corresponding real slide
        if (index === 0) {
          // was lastClone -> jump to last real
          snapToIndex(realCount, false);
        } else if (index === total - 1) {
          // was firstClone -> jump to first real
          snapToIndex(1, false);
        }
      };

      const updateGhostLabels = () => {
        const total = slides().length;
        const realCount = total - 2;

        // map current index (1..realCount) to names array (0..realCount-1)
        const realIdx = Math.min(Math.max(index - 1, 0), realCount - 1);

        const prevIdx = (realIdx - 1 + realCount) % realCount;
        const nextIdx = (realIdx + 1) % realCount;

        prevLabelEl.textContent = names[prevIdx] || "";
        nextLabelEl.textContent = names[nextIdx] || "";
      };

      const measure = () => {
        width = viewport.getBoundingClientRect().width;
        snapToIndex(index, false);
      };

      const goPrev = () => snapToIndex(index - 1, true);
      const goNext = () => snapToIndex(index + 1, true);

      // buttons
      prevBtn.addEventListener("click", goPrev);
      nextBtn.addEventListener("click", goNext);

      // transition end -> normalize for infinite
      track.addEventListener("transitionend", () => normalizeIndex());

      // pointer swipe (works for touch + mouse)
      const onDown = (e) => {
        // only left button for mouse
        if (e.pointerType === "mouse" && e.button !== 0) return;

        isDragging = true;
        startX = e.clientX;
        currentX = startX;

        // stop any running animation
        cancelAnimationFrame(raf);
        setTransition(false);

        // capture pointer
        viewport.setPointerCapture?.(e.pointerId);
      };

      const onMove = (e) => {
        if (!isDragging) return;
        currentX = e.clientX;
        const dx = currentX - startX;

        cancelAnimationFrame(raf);
        raf = requestAnimationFrame(() => {
          setTranslate(baseTranslate + dx);
        });
      };

      const onUp = () => {
        if (!isDragging) return;
        isDragging = false;

        const dx = currentX - startX;
        const threshold = Math.max(44, width * 0.18);

        if (dx > threshold) {
          goPrev();
        } else if (dx < -threshold) {
          goNext();
        } else {
          snapToIndex(index, true);
        }
      };

      viewport.addEventListener("pointerdown", onDown);
      viewport.addEventListener("pointermove", onMove);
      viewport.addEventListener("pointerup", onUp);
      viewport.addEventListener("pointercancel", onUp);
      viewport.addEventListener("lostpointercapture", onUp);

      // keyboard
      root.addEventListener("keydown", (e) => {
        if (e.key === "ArrowLeft") goPrev();
        if (e.key === "ArrowRight") goNext();
      });

      // resize
      const ro = new ResizeObserver(() => measure());
      ro.observe(viewport);

      // init
      measure();
      updateGhostLabels();
      snapToIndex(1, false);
    })();
  </script>
</section>
