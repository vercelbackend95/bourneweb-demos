---
import "./_services.css";

const categories = [
  {
    id: "cuts",
    label: "CUTS",
    image:
      "https://images.unsplash.com/photo-1520975958225-9e049b9f3fd1?auto=format&fit=crop&w=1200&q=80",
    items: [
      ["Men’s haircut", "£22"],
      ["Men’s haircut “Admiral”", "£26"],
      ["Haircut + beard", "£30"],
      ["Skin fade", "£28"],
      ["Children’s haircut", "£17"],
      ["Hair treatments", "£7–£15"],
    ],
  },
  {
    id: "beard",
    label: "BEARD & SHAVE",
    image:
      "https://images.unsplash.com/photo-1517832207067-4db24a2ae47c?auto=format&fit=crop&w=1200&q=80",
    items: [
      ["Beard care (shape)", "£7"],
      ["Beard trim", "£14"],
      ["Beard sculpt + line-up", "£16"],
      ["Beard colouring", "£15"],
      ["Shaving (regular)", "£12"],
      ["Hot towel shave", "£18"],
    ],
  },
  {
    id: "extras",
    label: "EXTRAS",
    image:
      "https://images.unsplash.com/photo-1503951914875-452162b0f3f1?auto=format&fit=crop&w=1200&q=80",
    items: [
      ["Eyebrows", "£6"],
      ["Nose wax", "£8"],
      ["Head massage", "£10"],
      ["Face cleanse", "£9"],
      ["Grey blending", "£12"],
      ["Beard oil treatment", "£7"],
    ],
  },
];
---

<section class="bms" aria-label="Prices and services" id="services">
  <div class="bms__inner">
    <header class="bms__head">
      <p class="bm-kicker">PRICES</p>
      <h2 class="bms__title">Pick your service</h2>
      <p class="bm-lead">Swipe or use arrows — image, label and prices move together.</p>
    </header>

    <div class="bms-carousel" data-carousel>
      <button class="bms-nav bms-nav--prev" type="button" aria-label="Previous category" data-prev>
        <span class="bms-nav__icon" aria-hidden="true">←</span>
        <span class="bms-nav__ghost" data-prev-label>EXTRAS</span>
      </button>

      <div class="bms-viewport" data-viewport>
        <div class="bms-track" data-track>
          {categories.map((cat) => (
            <article class="bms-slide" data-slide data-id={cat.id} aria-label={cat.label}>
              <div class="bms-hero">
                <div class="bms-hero__media">
                  <img class="bms-hero__img" src={cat.image} alt="" loading="lazy" />
                  <span class="bms-hero__ring" aria-hidden="true"></span>
                </div>
                <h3 class="bms-hero__label">{cat.label}</h3>
              </div>

              <div class="bms-list" role="list">
                {cat.items.map(([name, price]) => (
                  <div class="bms-row" role="listitem">
                    <div class="bms-row__name">{name}</div>
                    <div class="bms-row__price">{price}</div>
                  </div>
                ))}
              </div>
            </article>
          ))}
        </div>
      </div>

      <button class="bms-nav bms-nav--next" type="button" aria-label="Next category" data-next>
        <span class="bms-nav__ghost" data-next-label>CUTS</span>
        <span class="bms-nav__icon" aria-hidden="true">→</span>
      </button>
    </div>
  </div>

  <script is:inline>
    (() => {
      const root = document.querySelector("[data-carousel]");
      if (!root) return;

      const viewport = root.querySelector("[data-viewport]");
      const track = root.querySelector("[data-track]");
      const prevBtn = root.querySelector("[data-prev]");
      const nextBtn = root.querySelector("[data-next]");
      const prevLabelEl = root.querySelector("[data-prev-label]");
      const nextLabelEl = root.querySelector("[data-next-label]");

      if (!viewport || !track || !prevBtn || !nextBtn || !prevLabelEl || !nextLabelEl) return;

      const baseSlides = Array.from(track.querySelectorAll("[data-slide]"));
      if (baseSlides.length < 2) return;

      const names = baseSlides.map((s) => (s.getAttribute("aria-label") || "").trim());

      // ---- infinite clones (safe) ----
      const firstClone = baseSlides[0].cloneNode(true);
      const lastClone = baseSlides[baseSlides.length - 1].cloneNode(true);
      firstClone.setAttribute("data-clone", "true");
      lastClone.setAttribute("data-clone", "true");
      track.insertBefore(lastClone, baseSlides[0]);
      track.appendChild(firstClone);

      const slides = () => Array.from(track.children);

      let index = 1; // first real (0 = lastClone)
      let width = 1;

      let isDragging = false;
      let axis = null; // "x" | "y" | null
      let pointerId = null;

      let startX = 0;
      let startY = 0;
      let lastX = 0;

      let baseTranslate = 0;
      let raf = 0;

      let idleTimer = 0;

      const setTransition = (on) => {
        track.style.transition = on ? "transform 520ms cubic-bezier(.22,1,.36,1)" : "none";
      };

      const setTranslate = (x) => {
        track.style.transform = `translate3d(${x}px,0,0)`;
      };

      const updateGhostLabels = () => {
        const total = slides().length;
        const realCount = total - 2;
        const realIdx = Math.min(Math.max(index - 1, 0), realCount - 1);
        const prevIdx = (realIdx - 1 + realCount) % realCount;
        const nextIdx = (realIdx + 1) % realCount;

        prevLabelEl.textContent = names[prevIdx] || "";
        nextLabelEl.textContent = names[nextIdx] || "";
      };

      const snapToIndex = (i, animate = true) => {
        index = i;
        baseTranslate = -index * width;
        setTransition(animate);
        setTranslate(baseTranslate);
        updateGhostLabels();
      };

      const normalizeIndex = () => {
        const total = slides().length;
        const realCount = total - 2;

        if (index === 0) snapToIndex(realCount, false);
        else if (index === total - 1) snapToIndex(1, false);
      };

      const measure = () => {
        width = Math.max(1, viewport.getBoundingClientRect().width);
        snapToIndex(index, false);
      };

      const goPrev = () => snapToIndex(index - 1, true);
      const goNext = () => snapToIndex(index + 1, true);

      prevBtn.addEventListener("click", goPrev);
      nextBtn.addEventListener("click", goNext);
      track.addEventListener("transitionend", () => normalizeIndex());

      // ====== Drag that always ends in a full card ======
      const clearIdle = () => {
        if (idleTimer) window.clearTimeout(idleTimer);
        idleTimer = 0;
      };

      const armIdleSnap = () => {
        clearIdle();
        idleTimer = window.setTimeout(() => {
          if (isDragging) onUp(); // force end if events got lost
        }, 140);
      };

      const addGlobalEnd = () => {
        window.addEventListener("pointerup", onUp, { passive: true });
        window.addEventListener("pointercancel", onUp, { passive: true });
        window.addEventListener("blur", onUp, { passive: true });
        document.addEventListener("visibilitychange", onVis, { passive: true });
      };

      const removeGlobalEnd = () => {
        window.removeEventListener("pointerup", onUp);
        window.removeEventListener("pointercancel", onUp);
        window.removeEventListener("blur", onUp);
        document.removeEventListener("visibilitychange", onVis);
      };

      const onVis = () => {
        if (document.visibilityState !== "visible") onUp();
      };

      const onDown = (e) => {
        if (e.pointerType === "mouse" && e.button !== 0) return;

        isDragging = true;
        axis = null;
        pointerId = e.pointerId;

        startX = e.clientX;
        startY = e.clientY;
        lastX = startX;

        cancelAnimationFrame(raf);
        setTransition(false);

        viewport.classList.add("is-dragging");
        viewport.setPointerCapture?.(pointerId);

        addGlobalEnd();
        armIdleSnap();
      };

      const onMove = (e) => {
        if (!isDragging) return;
        if (pointerId != null && e.pointerId != null && e.pointerId !== pointerId) return;

        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        lastX = e.clientX;

        if (!axis) {
          if (Math.hypot(dx, dy) < 8) return;
          axis = Math.abs(dx) > Math.abs(dy) ? "x" : "y";

          // vertical gesture = let page scroll, snap back
          if (axis === "y") {
            isDragging = false;
            viewport.classList.remove("is-dragging");
            removeGlobalEnd();
            clearIdle();
            snapToIndex(index, true);
            axis = null;
            pointerId = null;
            return;
          }
        }

        if (axis === "x") {
          e.preventDefault();
          armIdleSnap();

          cancelAnimationFrame(raf);
          raf = requestAnimationFrame(() => {
            setTranslate(baseTranslate + dx);
          });
        }
      };

      const onUp = () => {
        if (!isDragging) return;

        isDragging = false;
        viewport.classList.remove("is-dragging");
        removeGlobalEnd();
        clearIdle();

        const dx = lastX - startX;
        const threshold = Math.max(48, width * 0.18);

        // Always end at a full slide
        if (axis === "x") {
          if (dx > threshold) goPrev();
          else if (dx < -threshold) goNext();
          else snapToIndex(index, true);
        } else {
          snapToIndex(index, true);
        }

        axis = null;
        pointerId = null;
      };

      viewport.addEventListener("pointerdown", onDown);
      viewport.addEventListener("pointermove", onMove, { passive: false });
      viewport.addEventListener("pointerup", onUp, { passive: true });
      viewport.addEventListener("pointercancel", onUp, { passive: true });
      viewport.addEventListener("lostpointercapture", onUp, { passive: true });

      const ro = new ResizeObserver(() => measure());
      ro.observe(viewport);

      measure();
      updateGhostLabels();
      snapToIndex(1, false);
    })();
  </script>
</section>
